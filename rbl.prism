mdp

global pos : int init 0;//0 is starting position


const int reward_pos; //temporary

const int maxstr;


global HCtoOFC1 : int init 1;
global HCtoOFC2 : int init 1;
global HCtoOFC3 : int init 1;


const rewardwait_threshold;
const ofc_connect_threshold;
const ofc_move_threshold;





module agentMotor

s : int init 0;




[] (HCtoOFC1>=ofc_move_threshold & HCtoOFC1>HCtoOFC2 & HCtoOFC1>HCtoOFC3)->(pos' = 1);
[] (HCtoOFC2>=ofc_move_threshold & HCtoOFC2>HCtoOFC1 & HCtoOFC2>HCtoOFC3)->(pos' = 2);
[] (HCtoOFC3>=ofc_move_threshold & HCtoOFC3>HCtoOFC1 & HCtoOFC3>HCtoOFC2)->(pos' = 3);
[] (HCtoOFC1<ofc_move_threshold & HCtoOFC2<ofc_move_threshold & HCtoOFC3<ofc_move_threshold | HCtoOFC1=HCtoOFC2 & HCtoOFC1=HCtoOFC3)-> 1/3 : (pos'=1) + 1/3 : (pos'=2) + 1/3 : (pos'=3);
[] (pos = reward_pos)->(pos' = 0);


endmodule


module OFC

[] (HCtoOFC1 * DRNtoOFC < maxstr & HC=1 & DRNtoOFC > ofc_connect_threshold) -> (HCtoOFC1' = HCtoOFC1 * DRNtoOFC) & (pos'=0);
[] (HCtoOFC2 * DRNtoOFC < maxstr & HC=2 & DRNtoOFC > ofc_connect_threshold) -> (HCtoOFC2' = HCtoOFC2 * DRNtoOFC) & (pos'=0);
[] (HCtoOFC3 * DRNtoOFC < maxstr & HC=3 & DRNtoOFC > ofc_connect_threshold) -> (HCtoOFC3' = HCtoOFC3 * DRNtoOFC) & (pos'=0); //must reset position from here :(

endmodule


formula HC = (pos=1?1:(pos=2?2:pos=3?3:0));
formula DRNtoOFC = (LH=1?3:(LH=0?0:0));
//TODO formula DRN to mPFC
formula LH = (pos=reward_pos?1:0);





