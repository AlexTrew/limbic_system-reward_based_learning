mdp







//const int maxstr;

const  reward_reset_step;







const rewardwait_threshold;
const ofc_connect_threshold;
const ofc_move_threshold;





module agentMotor

pos : [0..100] init 0;//0 is starting position


ss : [0..200] init 0;

am_state : [0..10] init 0;

reward_pos : [0..100] init 1; //temporary TODO add mPFC model

[] (am_state = 0 & HCtoOFC1>=ofc_move_threshold & HCtoOFC1>HCtoOFC2 & HCtoOFC1>HCtoOFC3) -> 1/3 : (pos'=1) & (am_state' = 1) + 1/3 : (pos'=2) & (am_state' = 1) + 1/3 : (pos'=3) & (am_state' = 1); //TODO add DRN excitement
[] (am_state = 0 & HCtoOFC2>=ofc_move_threshold & HCtoOFC2>HCtoOFC1 & HCtoOFC2>HCtoOFC3) -> 1/3 : (pos'=1) & (am_state' = 1) + 1/3 : (pos'=2) & (am_state' = 1) + 1/3 : (pos'=3) & (am_state' = 1); //TODO add DRN excitement
[] (am_state = 0 & HCtoOFC3>=ofc_move_threshold & HCtoOFC3>HCtoOFC1 & HCtoOFC3>HCtoOFC2) -> 1/3 : (pos'=1) & (am_state' = 1) + 1/3 : (pos'=2) & (am_state' = 1) + 1/3 : (pos'=3) & (am_state' = 1); //TODO add DRN excitement
[] (am_state = 0 & HCtoOFC1<ofc_move_threshold & HCtoOFC2<ofc_move_threshold & HCtoOFC3<ofc_move_threshold)-> 1/3 : (pos'=1) & (am_state' = 1) + 1/3 : (pos'=2) & (am_state' = 1) + 1/3 : (pos'=3) &  (am_state' = 1);

[signal] (am_state = 1 & ss<reward_reset_step)->(pos' = 0) & (ss' = ss + 1) & (am_state' = 0);

[reset] (am_state = 1 & ss=reward_reset_step) -> 1/3 :(reward_pos'=1) & (am_state' = 0) + 1/3 :(reward_pos'=2) & (am_state' = 0) + 1/3 :(reward_pos'=3) & (ss' = 0) & (am_state' = 0);

endmodule


module OFC

HCtoOFC1key : [0..100] init 0;
HCtoOFC2key : [0..100] init 0;
HCtoOFC3key : [0..100] init 0;

[signal] (DRNtoOFC = 3 & HCtoOFC1key < 2 & HC=1) -> (HCtoOFC1key' = HCtoOFC1key + 1);
[signal] (DRNtoOFC = 3 & HCtoOFC2key < 2 & HC=2) -> (HCtoOFC2key' = HCtoOFC2key + 1);
[signal] (DRNtoOFC = 3 & HCtoOFC3key < 2 & HC=3) -> (HCtoOFC3key' = HCtoOFC3key + 1); 

[signal] (DRNtoOFC = 3 & HCtoOFC1key = 2 & HC=1) -> (HCtoOFC1key' = 2);
[signal] (DRNtoOFC = 3 & HCtoOFC2key = 2 & HC=2) -> (HCtoOFC2key' = 2);
[signal] (DRNtoOFC = 3 & HCtoOFC3key = 2 & HC=3) -> (HCtoOFC3key' = 2);



[signal] (DRNtoOFC = 1 & HCtoOFC1key > 0 & HC=1) -> (HCtoOFC1key' = HCtoOFC1key - 1);
[signal] (DRNtoOFC = 1 & HCtoOFC2key > 0 & HC=2) -> (HCtoOFC2key' = HCtoOFC2key - 1);
[signal] (DRNtoOFC = 1 & HCtoOFC3key > 0 & HC=3) -> (HCtoOFC3key' = HCtoOFC3key - 1); 


[signal] (DRNtoOFC = 1 & HCtoOFC1key = 0 & HC=1) -> (HCtoOFC1key' = 0);
[signal] (DRNtoOFC = 1 & HCtoOFC2key = 0 & HC=2) -> (HCtoOFC2key' = 0);
[signal] (DRNtoOFC = 1 & HCtoOFC3key = 0 & HC=3) -> (HCtoOFC3key' = 0);


//choose weight function hypothesis non deterministically; resolve for max P of success

endmodule


formula HC = (pos=1?1:(pos=2?2:pos=3?3:0));
formula DRNtoOFC = (LH=1?3:(LH=0?1:1));
//TODO formula DRN to mPFC
formula LH = (pos=reward_pos?1:0);



formula HCtoOFC1 = HCtoOFC1key=0?10:(HCtoOFC1key=1?30:(HCtoOFC1key=2?90:(HCtoOFC1key=2?200:0)));
formula HCtoOFC2 = HCtoOFC2key=0?10:(HCtoOFC2key=1?30:(HCtoOFC2key=2?90:(HCtoOFC2key=2?200:0)));
formula HCtoOFC3 = HCtoOFC3key=0?10:(HCtoOFC3key=1?30:(HCtoOFC3key=2?90:(HCtoOFC3key=2?200:0)));






