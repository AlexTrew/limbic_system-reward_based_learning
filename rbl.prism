mdp


//const int maxstr;


//agent motor out of pf vars

const reward_reset_step;

const drn_reward_wait_threshold;



const pf_length;
const delay;

const mpfc_random_speed_lo;
const mpfc_random_speed_med;
const mpfc_random_speed_hi;

const reward_unseen_speed; //must be based on lookup table
const reward_seen_speed;
const reward_pos_in_pf; //must be significantly less than pf_length

global reward_collected : bool init false;
global waiting : bool init false;
global in_reward_pf : bool init false;

 //temporary TODO add mPFC model






module agentMotor

//am_state=0: random movement to pf
//am_state=1: agent is in pf; if drn > drn_move_threshold AND pf corresponds with learned reward location, goto am_state = 3, else, goto am_state=2
//am_state=2: agent is advancing at random speed. If agent reaches reward landmark, goto am_state = todo (end)
//am_state=3: agent is advancing using speed determined by DRN output,If agent reaches reward landmark, goto am_state = todo (end)
//am_state=4: check if agent has received reward. output OFCtoDRN as necessary
//am_state=5: signal OFC 
//am_state=6: reset to am_state=0;

pos : [0..100] init 0;//0 is starting position //TODO rename pf
inpf_pos : [0..pf_length];
ss : [0..200] init 0; //reward location reset counter
am_state : [0..10] init 0; //state counter for this module

vis1 : [0..1] init 0;
vis2 : [0..1] init 0;

reward_pos : [0..100] init 1;


[] (am_state = 0 )-> //random movement
1/3 : (pos'=1) & (am_state' = 1)  + 1/3 : (pos'=2) & (am_state' = 1)  + 1/3 : (pos'=3) &  (am_state' = 1);

[] am_state=1 & HC = reward_pos -> (in_reward_pf'=true);

[] am_state=1 & ((HC=1 & OFC1toDRN>drn_reward_wait_threshold) 
| (HC=2 & OFC2toDRN>drn_reward_wait_threshold) 
| (HC=3 & OFC3toDRN>drn_reward_wait_threshold)) -> //if agent in same pf as learned reward location, goto am_state=3
	(am_state'=3) & (waiting'=true);

[] am_state=1 & (!(HC=1 & OFC1toDRN>drn_reward_wait_threshold) 
| !(HC=2 & OFC2toDRN>drn_reward_wait_threshold) 
| !(HC=3 & OFC3toDRN>drn_reward_wait_threshold)) -> //else, goto am_state=2 //TODO refine guard
	(am_state'=2)  & (waiting'=true);

[agent_move] am_state=2 ->
	 1/3 : (vis1'=1) & (inpf_pos' = inpf_pos + mpfc_random_speed_lo) +
	 1/3 : (vis1'=1) & (inpf_pos' = inpf_pos + mpfc_random_speed_med) +
	 1/3 : (vis1'=1) & (inpf_pos' = inpf_pos + mpfc_random_speed_hi); 

//TODO am_state=3

[agent_move] (am_state=2 | am_state = 3) & inpf_pos>= reward_pos_in_pf ->
	(am_state'=4);

[] am_state=4 & in_reward_pf = true & reward_present = true ->
	(reward_collected'=true) & (am_state'=5) & (waiting'=false) & (inpf_pos'=0);

[] am_state=4 & reward_present = true & in_reward_pf= false ->
	(reward_collected'=false) & (am_state'=5) & (waiting'=false) & (inpf_pos'=0);

[] am_state=4 & reward_present = false & in_reward_pf= true ->
	(reward_collected'=false) & (am_state'=5) & (waiting'=false) & (inpf_pos'=0);

[] am_state=4 & reward_present = false & in_reward_pf= false ->
	(reward_collected'=false) & (am_state'=5) & (waiting'=false) & (inpf_pos'=0);

[signalOFC] (am_state = 5 & ss!=reward_reset_step)->(ss' = ss + 1) & (am_state' = 6); //send signal to OFC and reset am_state

[reset] (am_state = 5 & ss=reward_reset_step) ->   //reset reward location on reset_reward_step
	1/3 :(pos'=0) & (am_state' = 6) & (reward_pos' = 1) & (ss' = 0) + 
	1/3 :(pos'=0) & (am_state' = 6) & (reward_pos' = 2) & (ss' = 0) + 
	1/3 :(pos'=0) & (am_state' = 6) & (reward_pos' = 3) & (ss' = 0);

[] am_state = 6->(pos' = 0) & (am_state'=0) & (reward_collected'=false) & (in_reward_pf'=false);





endmodule




module OFC

HCtoOFC1key : [0..100] init 0;
HCtoOFC2key : [0..100] init 0;
HCtoOFC3key : [0..100] init 0;


[signalOFC] (DRNtoOFC = 3 & HCtoOFC1key < 2 & HC=1) ->
 (HCtoOFC1key' = HCtoOFC1key + 1);

[signalOFC] (DRNtoOFC = 3 & HCtoOFC2key < 2 & HC=2) ->
 (HCtoOFC2key' = HCtoOFC2key + 1);

[signalOFC] (DRNtoOFC = 3 & HCtoOFC3key < 2 & HC=3) ->
 (HCtoOFC3key' = HCtoOFC3key + 1); 

//add OFC to DRN signal based on LH



[signalOFC] (DRNtoOFC = 3 & HCtoOFC1key = 2 & HC=1) -> 
	(HCtoOFC1key' = 2);
[signalOFC] (DRNtoOFC = 3 & HCtoOFC2key = 2 & HC=2) -> 
	(HCtoOFC2key' = 2);
[signalOFC] (DRNtoOFC = 3 & HCtoOFC3key = 2 & HC=3) -> 
	(HCtoOFC3key' = 2);



[signalOFC] (DRNtoOFC = 1 & HCtoOFC1key > 0 & HC=1) ->
 (HCtoOFC1key' = HCtoOFC1key - 1);

[signalOFC] (DRNtoOFC = 1 & HCtoOFC2key > 0 & HC=2) ->
 (HCtoOFC2key' = HCtoOFC2key - 1);

[signalOFC] (DRNtoOFC = 1 & HCtoOFC3key > 0 & HC=3) ->
 (HCtoOFC3key' = HCtoOFC3key - 1);


[signalOFC] (DRNtoOFC = 1 & HCtoOFC1key = 0 & HC=1) -> (HCtoOFC1key' = 0);
[signalOFC] (DRNtoOFC = 1 & HCtoOFC2key = 0 & HC=2) -> (HCtoOFC2key' = 0);
[signalOFC] (DRNtoOFC = 1 & HCtoOFC3key = 0 & HC=3) -> (HCtoOFC3key' = 0);


//choose weight function hypothesis non deterministically; resolve for max P of success

endmodule

module DRN

OFC1toDRNkey : [0..100] init 0;
OFC2toDRNkey : [0..100] init 0;
OFC3toDRNkey : [0..100] init 0;


[signalOFC] (DRNtoOFC = 3 & OFC1toDRNkey < 2 & HC=1) ->
 (OFC1toDRNkey' = OFC1toDRNkey + 1);

[signalOFC] (DRNtoOFC = 3 & OFC2toDRNkey < 2 & HC=2) ->
 (OFC2toDRNkey' = OFC2toDRNkey + 1);

[signalOFC] (DRNtoOFC = 3 & OFC3toDRNkey < 2 & HC=3) ->
 (OFC3toDRNkey' = OFC3toDRNkey + 1); 

//add OFC to DRN signal based on LH



[signalOFC] (DRNtoOFC = 3 & OFC1toDRNkey = 2 & HC=1) -> 
	(OFC1toDRNkey' = 2);
[signalOFC] (DRNtoOFC = 3 & OFC2toDRNkey = 2 & HC=2) -> 
	(OFC2toDRNkey' = 2);
[signalOFC] (DRNtoOFC = 3 & OFC3toDRNkey = 2 & HC=3) -> 
	(OFC3toDRNkey' = 2);



[signalOFC] (DRNtoOFC = 1 & OFC1toDRNkey > 0) ->
 (OFC1toDRNkey' = OFC1toDRNkey - 1);

[signalOFC] (DRNtoOFC = 1 & OFC2toDRNkey > 0) ->
 (OFC2toDRNkey' = OFC2toDRNkey - 1);

[signalOFC] (DRNtoOFC = 1 & OFC3toDRNkey > 0) ->
 (OFC3toDRNkey' = OFC3toDRNkey - 1);


[signalOFC] (DRNtoOFC = 1 & OFC1toDRNkey = 0 & HC=1) -> (OFC1toDRNkey' = 0);
[signalOFC] (DRNtoOFC = 1 & OFC2toDRNkey = 0 & HC=2) -> (OFC2toDRNkey' = 0);
[signalOFC] (DRNtoOFC = 1 & OFC3toDRNkey = 0 & HC=3) -> (OFC3toDRNkey' = 0);

endmodule


//TODO move drntoOFC to separate module

module reward_spawner


c : [0..delay] init 0; //reward spawn delay counter CANNOT be zero
t : [0..10] init 0;  //state counter to help ordering of events

spwnd : bool init false;
despwnd : bool init false;
reward_present : bool init false;

[] (t=0) & waiting=false -> 1: (t' = 0);
[] (t=0) & waiting=true -> 1: (t' = 1);

[agent_move] (t=1) & spwnd=false & c<delay-> 1: (c'=c+1);  //increment reward spawn counter
[agent_move] (t=1) & spwnd=false & c>=delay -> (spwnd'=true) & (c'=0) & (reward_present'=true) & (t'=2); //spawn reward after "delay" steps
[agent_move] waiting=true & (t=2) & spwnd=true -> (t'=2);
[] waiting=false -> (t'=0) & (c'=0) & (spwnd'=false) & (reward_present'=false);

//TODO 
endmodule


formula HC = (pos=1?1:(pos=2?2:pos=3?3:0));
formula DRNtoOFC = (LH=1?3:(LH=0?1:1));
formula LH = (reward_collected=true?1:0);

// formula OFCtoDRN = 
//TODO formula DRN to mPFC



formula OFC1toDRN = (OFC1toDRNkey=0?10:(OFC1toDRNkey=1?30:(OFC1toDRNkey=2?90:(OFC1toDRNkey=2?200:0))));
formula OFC2toDRN = (OFC2toDRNkey=0?10:(OFC2toDRNkey=1?30:(OFC2toDRNkey=2?90:(OFC2toDRNkey=2?200:0))));
formula OFC3toDRN = (OFC3toDRNkey=0?10:(OFC3toDRNkey=1?30:(OFC3toDRNkey=2?90:(OFC3toDRNkey=2?200:0))));


formula HCtoOFC1 = HCtoOFC1key=0?10:(HCtoOFC1key=1?30:(HCtoOFC1key=2?90:(HCtoOFC1key=2?200:0)));
formula HCtoOFC2 = HCtoOFC2key=0?10:(HCtoOFC2key=1?30:(HCtoOFC2key=2?90:(HCtoOFC2key=2?200:0)));
formula HCtoOFC3 = HCtoOFC3key=0?10:(HCtoOFC3key=1?30:(HCtoOFC3key=2?90:(HCtoOFC3key=2?200:0)));

formula x = vis1 + vis2; //speed based on visual inputs

formula mPFC_out = ((x=1)?reward_unseen_speed:(x=2)?reward_seen_speed:0);

//TODO reward_unseen_speed formula








