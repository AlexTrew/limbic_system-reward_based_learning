mdp


//const int maxstr;

const reward_reset_step;


const rewardwait_threshold;
const ofc_connect_threshold;
const ofc_move_threshold;
const pf_length;
const MAX_reward_pos;
const delay;

const mpfc_random_speed_lo;
const mpfc_random_speed_med;
const mpfc_random_speed_hi;

const reward_unseen_speed;
const reward_seen_speed;

global reward_collected : bool init false;
global waiting : bool init false;
global in_reward_pf : bool init false;


module agentMotor

//am_state = 0: random movement
//am_state= 2: signal OFC + reset to am_state=0;


pos : [0..100] init 0;//0 is starting position


ss : [0..200] init 0;

am_state : [0..10] init 0;

reward_pos : [0..100] init 1; //temporary TODO add mPFC model

[] (am_state = 0 )-> //random movement
1/3 : (pos'=1) & (am_state' = 1) + 1/3 : (pos'=2) & (am_state' = 1) + 1/3 : (pos'=3) &  (am_state' = 1);

//DO mpfc

[signalOFC] (am_state = 1 & ss!=reward_reset_step)->(pos' = 0) & (ss' = ss + 1) & (am_state' = 0); //send signal to OFC and reset am_state

[reset] (am_state = 2 & ss=reward_reset_step) ->   //reset reward location on reset_reward_step
	1/3 :(pos'=0) & (am_state' = 0) & (reward_pos' = 1) & (ss' = 0) + 
	1/3 :(pos'=0) & (am_state' = 0) & (reward_pos' = 2) & (ss' = 0) + 
	1/3 :(pos'=0) & (am_state' = 0) & (reward_pos' = 3) & (ss' = 0);

endmodule


module OFC

HCtoOFC1key : [0..100] init 0;
HCtoOFC2key : [0..100] init 0;
HCtoOFC3key : [0..100] init 0;
OFC1toDRNkey : [0..100] init 0;
OFC2toDRNkey : [0..100] init 0;
OFC3toDRNkey : [0..100] init 0;

[signalOFC] (DRNtoOFC = 3 & HCtoOFC1key < 2 & HC=1) ->
 (HCtoOFC1key' = HCtoOFC1key + 1) & (OFC1toDRNkey' = OFC1toDRNkey + 1);

[signalOFC] (DRNtoOFC = 3 & HCtoOFC2key < 2 & HC=2) ->
 (HCtoOFC2key' = HCtoOFC2key + 1) & (OFC2toDRNkey' = OFC2toDRNkey + 1);

[signalOFC] (DRNtoOFC = 3 & HCtoOFC3key < 2 & HC=3) ->
 (HCtoOFC3key' = HCtoOFC3key + 1) & (OFC3toDRNkey' = OFC3toDRNkey + 1); 

//add OFC to DRN signal based on LH



[signalOFC] (DRNtoOFC = 3 & HCtoOFC1key = 2 & HC=1) -> (HCtoOFC1key' = 2);
[signalOFC] (DRNtoOFC = 3 & HCtoOFC2key = 2 & HC=2) -> (HCtoOFC2key' = 2);
[signalOFC] (DRNtoOFC = 3 & HCtoOFC3key = 2 & HC=3) -> (HCtoOFC3key' = 2);



[signalOFC] (DRNtoOFC = 1 & HCtoOFC1key > 0 & HC=1) ->
 (HCtoOFC1key' = HCtoOFC1key - 1) & (OFC1toDRNkey' = OFC1toDRNkey - 1);

[signalOFC] (DRNtoOFC = 1 & HCtoOFC2key > 0 & HC=2) ->
 (HCtoOFC2key' = HCtoOFC2key - 1) & (OFC2toDRNkey' = OFC2toDRNkey - 1);

[signalOFC] (DRNtoOFC = 1 & HCtoOFC3key > 0 & HC=3) ->
 (HCtoOFC3key' = HCtoOFC3key - 1) & (OFC3toDRNkey' = OFC3toDRNkey - 1);


[signalOFC] (DRNtoOFC = 1 & HCtoOFC1key = 0 & HC=1) -> (HCtoOFC1key' = 0);
[signalOFC] (DRNtoOFC = 1 & HCtoOFC2key = 0 & HC=2) -> (HCtoOFC2key' = 0);
[signalOFC] (DRNtoOFC = 1 & HCtoOFC3key = 0 & HC=3) -> (HCtoOFC3key' = 0);


//choose weight function hypothesis non deterministically; resolve for max P of success

endmodule

//TODO mpfc module

module mpfc


mpfc_s : [0..100] init 1; //state counter for mpfc

vis1 : [0..1] init 0;
vis2 : [0..1] init 0;
reward_pos_mpfc : [0..pf_length] init 0;
speedtype : [0..2];
reward_pos_pf : [0..MAX_reward_pos]; //PF number containing reward
agent_pos : [0..pf_length] init 0;


at_reward : bool init false;
collected_reward : bool init false;
missed_reward : bool init false;

//s=1 -> check DRN -> move randomly if too low
//s=2 -> has seen visual landmark, slowed down, waiting for reward
//s=3 -> has seen reward, moving towards location of reward
//s=4 -> reached reward location, hit or miss
//s=5 -> at end



[] mpfc_s = 1 & LH = 1 & OFC1toDRN < rewardwait_threshold ->
  1/3 : (agent_pos' = agent_pos + mpfc_random_speed_lo) +   
  1/3 : (agent_pos' = agent_pos + mpfc_random_speed_med) +
  1/3 : (agent_pos' = agent_pos + mpfc_random_speed_hi);

[] mpfc_s = 1 & LH = 2 & OFC2toDRN < rewardwait_threshold ->
  1/3 : (agent_pos' = agent_pos + mpfc_random_speed_lo) +   
  1/3 : (agent_pos' = agent_pos + mpfc_random_speed_med) +
  1/3 : (agent_pos' = agent_pos + mpfc_random_speed_hi);

[] mpfc_s = 1 & LH = 3 & OFC3toDRN < rewardwait_threshold ->
  1/3 : (agent_pos' = agent_pos + mpfc_random_speed_lo) +   
  1/3 : (agent_pos' = agent_pos + mpfc_random_speed_med) +
  1/3 : (agent_pos' = agent_pos + mpfc_random_speed_hi);








endmodule

module reward_spawner


c : [0..delay] init 0; //reward spawn delay counter CANNOT be zero
t : [0..10] init 0;  //state counter to help ordering of events

spwnd : bool init false;
despwnd : bool init false;
reward_present : bool init false;

[] (t=0) & waiting=false -> 1: (t' = 0);
[] (t=0) & waiting=true -> 1: (t' = 1);

[timed] (t=1) & spwnd=false & c<delay-> 1: (c'=c+1);  //increment reward spawn counter
[timed] (t=1) & spwnd=false & c>=delay -> (spwnd'=true) & (c'=0) & (reward_present'=true) & (t'=2); //spawn reward after "delay" steps
[timed](t=2) -> (t'=2);

endmodule


formula HC = (pos=1?1:(pos=2?2:pos=3?3:0));
formula DRNtoOFC = (LH=1?3:(LH=0?1:1));
// formula OFCtoDRN = 
//TODO formula DRN to mPFC
formula LH = (pos=reward_pos?1:0);


formula OFC1toDRN = LH=1?(OFC1toDRNkey=0?10:(OFC1toDRNkey=1?30:(OFC1toDRNkey=2?90:(OFC1toDRNkey=2?200:0)))):0;
formula OFC2toDRN = LH=2?(OFC2toDRNkey=0?10:(OFC2toDRNkey=1?30:(OFC2toDRNkey=2?90:(OFC2toDRNkey=2?200:0)))):0;
formula OFC3toDRN = LH=3?(OFC3toDRNkey=0?10:(OFC3toDRNkey=1?30:(OFC3toDRNkey=2?90:(OFC3toDRNkey=2?200:0)))):0;


formula HCtoOFC1 = HCtoOFC1key=0?10:(HCtoOFC1key=1?30:(HCtoOFC1key=2?90:(HCtoOFC1key=2?200:0)));
formula HCtoOFC2 = HCtoOFC2key=0?10:(HCtoOFC2key=1?30:(HCtoOFC2key=2?90:(HCtoOFC2key=2?200:0)));
formula HCtoOFC3 = HCtoOFC3key=0?10:(HCtoOFC3key=1?30:(HCtoOFC3key=2?90:(HCtoOFC3key=2?200:0)));

formula x = vis1 + vis2; //speed based on visual inputs

formula mPFC_out = ((x=1)?reward_unseen_speed:(x=2)?reward_seen_speed:0);








