mdp







//const int maxstr;

const  reward_reset_step;







const rewardwait_threshold;
const ofc_connect_threshold;
const ofc_move_threshold;





module agentMotor

//am_state = 0: random movement
//am_state = 1: check HC-OFC strngth and produce 5ht if necessary, try get reward (maybe split up into 2 states)
//am_state= 2: signal OFC + reset to am_state=0;

pos : [0..100] init 0;//0 is starting position


ss : [0..200] init 0;

am_state : [0..10] init 0;

reward_pos : [0..100] init 1; //temporary TODO add mPFC model

[] (am_state = 0 )-> 
1/3 : (pos'=1) & (am_state' = 1) + 1/3 : (pos'=2) & (am_state' = 1) + 1/3 : (pos'=3) &  (am_state' = 1);

[] (am_state = 1 & HCtoOFC1>=ofc_move_threshold) -> 
(am_state' = 2);
//TODO fire DRN excitement from here

[] (am_state = 1 & HCtoOFC2>=ofc_move_threshold) -> 
(am_state' = 2); 
//TODO add DRN excitement

[] (am_state = 1 & HCtoOFC3>=ofc_move_threshold) ->
 (am_state' = 2); 
//TODO add DRN excitement

[] (am_state = 1) & (HCtoOFC1<ofc_move_threshold) & (HCtoOFC2<ofc_move_threshold) & 
(HCtoOFC3<ofc_move_threshold) -> (am_state' = 2);


//random movement

[signalOFC] (am_state = 2 & ss!=reward_reset_step)->(pos' = 0) & (ss' = ss + 1) & (am_state' = 0);

[reset] (am_state = 2 & ss=reward_reset_step) ->   //reset reward location on reset_reward_step
	1/3 :(pos'=0) & (am_state' = 0) & (reward_pos' = 1) & (ss' = 0) + 
	1/3 :(pos'=0) & (am_state' = 0) & (reward_pos' = 2) & (ss' = 0) + 
	1/3 :(pos'=0) & (am_state' = 0) & (reward_pos' = 3) & (ss' = 0);

endmodule


module OFC

HCtoOFC1key : [0..100] init 0;
HCtoOFC2key : [0..100] init 0;
HCtoOFC3key : [0..100] init 0;

[signalOFC] (DRNtoOFC = 3 & HCtoOFC1key < 2 & HC=1) -> (HCtoOFC1key' = HCtoOFC1key + 1);
[signalOFC] (DRNtoOFC = 3 & HCtoOFC2key < 2 & HC=2) -> (HCtoOFC2key' = HCtoOFC2key + 1);
[signalOFC] (DRNtoOFC = 3 & HCtoOFC3key < 2 & HC=3) -> (HCtoOFC3key' = HCtoOFC3key + 1); 

[signalOFC] (DRNtoOFC = 3 & HCtoOFC1key = 2 & HC=1) -> (HCtoOFC1key' = 2);
[signalOFC] (DRNtoOFC = 3 & HCtoOFC2key = 2 & HC=2) -> (HCtoOFC2key' = 2);
[signalOFC] (DRNtoOFC = 3 & HCtoOFC3key = 2 & HC=3) -> (HCtoOFC3key' = 2);



[signalOFC] (DRNtoOFC = 1 & HCtoOFC1key > 0 & HC=1) -> (HCtoOFC1key' = HCtoOFC1key - 1);
[signalOFC] (DRNtoOFC = 1 & HCtoOFC2key > 0 & HC=2) -> (HCtoOFC2key' = HCtoOFC2key - 1);
[signalOFC] (DRNtoOFC = 1 & HCtoOFC3key > 0 & HC=3) -> (HCtoOFC3key' = HCtoOFC3key - 1); 


[signalOFC] (DRNtoOFC = 1 & HCtoOFC1key = 0 & HC=1) -> (HCtoOFC1key' = 0);
[signalOFC] (DRNtoOFC = 1 & HCtoOFC2key = 0 & HC=2) -> (HCtoOFC2key' = 0);
[signalOFC] (DRNtoOFC = 1 & HCtoOFC3key = 0 & HC=3) -> (HCtoOFC3key' = 0);


//choose weight function hypothesis non deterministically; resolve for max P of success

endmodule

//TODO mpfc module


formula HC = (pos=1?1:(pos=2?2:pos=3?3:0));
formula DRNtoOFC = (LH=1?3:(LH=0?1:1));
//TODO formula DRN to mPFC
formula LH = (pos=reward_pos?1:0);



formula HCtoOFC1 = HCtoOFC1key=0?10:(HCtoOFC1key=1?30:(HCtoOFC1key=2?90:(HCtoOFC1key=2?200:0)));
formula HCtoOFC2 = HCtoOFC2key=0?10:(HCtoOFC2key=1?30:(HCtoOFC2key=2?90:(HCtoOFC2key=2?200:0)));
formula HCtoOFC3 = HCtoOFC3key=0?10:(HCtoOFC3key=1?30:(HCtoOFC3key=2?90:(HCtoOFC3key=2?200:0)));






